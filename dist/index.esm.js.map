{"version":3,"file":"index.esm.js","sources":["../src/patchStore.ts","../src/useSelector.ts","../src/useTrackedState.ts","../src/utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/ban-ts-ignore */\n\nimport {\n  // @ts-ignore\n  createMutableSource,\n} from 'react';\nimport {\n  Action as ReduxAction,\n  Store,\n} from 'redux';\n\nexport type PatchedStore<State, Action extends ReduxAction<any>> = {\n  mutableSource: any;\n} & Store<State, Action>;\n\n/**\n * patch Redux store for React\n *\n * @example\n * import { createStore } from 'redux';\n * import { patchStore } from 'reactive-react-redux';\n *\n * const reducer = ...;\n * const store = patchStore(createStore(reducer));\n */\nexport const patchStore = <State, Action extends ReduxAction<any>>(\n  store: Store<State, Action>,\n) => {\n  const mutableSource = createMutableSource(store, () => store.getState());\n  (store as PatchedStore<State, Action>).mutableSource = mutableSource;\n  return store as PatchedStore<State, Action>;\n};\n\nexport const subscribe = <State, Action extends ReduxAction<any>>(\n  store: Store<State, Action>,\n  callback: () => void,\n) => {\n  const unsubscribe = store.subscribe(callback);\n  return unsubscribe;\n};\n","/* eslint-disable @typescript-eslint/ban-ts-ignore */\n\nimport {\n  useCallback,\n  // @ts-ignore\n  useMutableSource,\n} from 'react';\nimport {\n  Action as ReduxAction,\n  Store,\n} from 'redux';\n\nimport { PatchedStore, subscribe } from './patchStore';\n\n/**\n * useSelector hook\n *\n * selector has to be stable. Either define it outside render\n * or use useCallback if selector uses props.\n *\n * @example\n * import { useCallback } from 'react';\n * import { useSelector } from 'reactive-react-redux';\n *\n * const Component = ({ count }) => {\n *   const isBigger = useSelector(store, useCallack(state => state.count > count, [count]));\n *   ...\n * };\n */\nexport const useSelector = <State, Action extends ReduxAction<any>, Selected>(\n  patchedStore: PatchedStore<State, Action>,\n  selector: (state: State) => Selected,\n) => {\n  const { mutableSource } = patchedStore;\n  const getSnapshot = useCallback((store: Store<State, Action>) => (\n    selector(store.getState())\n  ), [selector]);\n  const selected: Selected = useMutableSource(mutableSource, getSnapshot, subscribe);\n  return selected;\n};\n","/* eslint-disable @typescript-eslint/ban-ts-ignore */\n\nimport {\n  useMemo,\n  // @ts-ignore\n  useMutableSource,\n} from 'react';\nimport {\n  Action as ReduxAction,\n  Store,\n} from 'redux';\nimport {\n  createDeepProxy,\n  isDeepChanged,\n  MODE_ASSUME_UNCHANGED_IF_UNAFFECTED,\n  MODE_IGNORE_REF_EQUALITY,\n  MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP,\n} from 'proxy-compare';\n\nimport { PatchedStore, subscribe } from './patchStore';\nimport { useAffectedDebugValue } from './utils';\n\nconst MODE_ALWAYS_ASSUME_CHANGED_IF_UNAFFECTED = 0;\nconst MODE_ALWAYS_ASSUME_UNCHANGED_IF_UNAFFECTED = (\n  MODE_ASSUME_UNCHANGED_IF_UNAFFECTED | MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP\n);\nconst MODE_MUTABLE_ROOT_STATE = MODE_IGNORE_REF_EQUALITY; // only for root\nconst MODE_DEFAULT = MODE_ASSUME_UNCHANGED_IF_UNAFFECTED; // only for root\n\ntype Opts = any; // TODO types\n\n/**\n * useTrackedState hook\n *\n * It return the Redux state wrapped by Proxy,\n * and the state prperty access is tracked.\n * It will only re-render if accessed properties are changed.\n *\n * @example\n * import { useTrackedState } from 'reactive-react-redux';\n *\n * const Component = () => {\n *   const state = useTrackedState(store);\n *   ...\n * };\n */\nexport const useTrackedState = <State, Action extends ReduxAction<any>>(\n  patchedStore: PatchedStore<State, Action>,\n  opts: Opts = {},\n) => {\n  const { mutableSource } = patchedStore;\n  const affected = new WeakMap();\n  const deepChangedMode = (\n    /* eslint-disable no-nested-ternary, indent, no-multi-spaces */\n      opts.unstable_forceUpdateForStateChange     ? MODE_ALWAYS_ASSUME_CHANGED_IF_UNAFFECTED\n    : opts.unstable_ignoreIntermediateObjectUsage ? MODE_ALWAYS_ASSUME_UNCHANGED_IF_UNAFFECTED\n    : opts.unstable_ignoreStateEquality           ? MODE_MUTABLE_ROOT_STATE\n    : /* default */                                 MODE_DEFAULT\n    /* eslint-enable no-nested-ternary, indent, no-multi-spaces */\n  );\n  const getSnapshot = useMemo(() => {\n    let prevState: State | null = null;\n    const deepChangedCache = new WeakMap();\n    return (store: Store<State, Action>) => {\n      const nextState = store.getState();\n      if (prevState !== null && prevState !== nextState && !isDeepChanged(\n        prevState,\n        nextState,\n        affected,\n        deepChangedCache,\n        deepChangedMode,\n      )) {\n        // not changed\n        return prevState;\n      }\n      prevState = nextState;\n      return nextState;\n    };\n  }, [affected, deepChangedMode]);\n  const state: State = useMutableSource(mutableSource, getSnapshot, subscribe);\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useAffectedDebugValue(state, affected);\n  }\n  const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache\n  return createDeepProxy(state, affected, proxyCache);\n};\n","import {\n  useEffect,\n  useRef,\n  useDebugValue,\n} from 'react';\n\nconst affectedToPathList = <State>(\n  state: State,\n  affected: WeakMap<object, Set<string>>,\n) => {\n  const list: string[][] = [];\n  const walk = (obj: unknown, path?: string[]) => {\n    const used = affected.get(obj as object);\n    if (used) {\n      used.forEach((key) => {\n        walk((obj as { [k: string]: object })[key], path ? [...path, key] : [key]);\n      });\n    } else if (path) {\n      list.push(path);\n    }\n  };\n  walk(state);\n  return list;\n};\n\nexport const useAffectedDebugValue = <State>(\n  state: State,\n  affected: WeakMap<object, Set<string>>,\n) => {\n  const pathList = useRef<string[][]>();\n  useEffect(() => {\n    pathList.current = affectedToPathList(state, affected);\n  });\n  useDebugValue(pathList);\n};\n"],"names":["patchStore","store","mutableSource","createMutableSource","getState","subscribe","callback","useSelector","patchedStore","selector","getSnapshot","useCallback","useMutableSource","MODE_ALWAYS_ASSUME_UNCHANGED_IF_UNAFFECTED","MODE_ASSUME_UNCHANGED_IF_UNAFFECTED","MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP","MODE_MUTABLE_ROOT_STATE","MODE_IGNORE_REF_EQUALITY","MODE_DEFAULT","useTrackedState","opts","affected","WeakMap","deepChangedMode","unstable_forceUpdateForStateChange","unstable_ignoreIntermediateObjectUsage","unstable_ignoreStateEquality","useMemo","prevState","deepChangedCache","nextState","isDeepChanged","state","process","env","NODE_ENV","pathList","useRef","useEffect","current","list","walk","obj","path","used","get","forEach","key","push","affectedToPathList","useDebugValue","useAffectedDebugValue","proxyCache","createDeepProxy"],"mappings":"iYAyBaA,IAAAA,EAAa,SACxBC,GAEA,IAAMC,EAAgBC,EAAoBF,EAAO,kBAAMA,EAAMG,aAE7D,OADCH,EAAsCC,cAAgBA,EAChDD,GAGII,EAAY,SACvBJ,EACAK,GAGA,OADoBL,EAAMI,UAAUC,ICRzBC,EAAc,SACzBC,EACAC,OAEQP,EAAkBM,EAAlBN,cACFQ,EAAcC,EAAY,SAACV,UAC/BQ,EAASR,EAAMG,aACd,CAACK,IAEJ,OAD2BG,EAAiBV,EAAeQ,EAAaL,ICdpEQ,EACJC,EAAsCC,EAElCC,EAA0BC,EAC1BC,EAAeJ,EAmBRK,EAAkB,SAC7BX,EACAY,YAAAA,IAAAA,EAAa,QAELlB,EAAkBM,EAAlBN,cACFmB,EAAW,IAAIC,QACfC,EAEFH,EAAKI,mCAhCsC,EAiC3CJ,EAAKK,uCAAyCZ,EAC9CO,EAAKM,6BAAyCV,EACAE,EAG5CR,EAAciB,EAAQ,WAC1B,IAAIC,EAA0B,KACxBC,EAAmB,IAAIP,QAC7B,gBAAQrB,GACN,IAAM6B,EAAY7B,EAAMG,WACxB,OAAkB,OAAdwB,GAAsBA,IAAcE,GAAcC,EACpDH,EACAE,EACAT,EACAQ,EACAN,IAKFK,EAAYE,EACLA,GAHEF,IAKV,CAACP,EAAUE,IACRS,EAAepB,EAAiBV,EAAeQ,EAAaL,GACrC,eAAzB4B,QAAQC,IAAIC,UCvDmB,SACnCH,EACAX,GAEA,IAAMe,EAAWC,IACjBC,EAAU,WACRF,EAASG,QAzBc,SACzBP,EACAX,GAEA,IAAMmB,EAAmB,GAYzB,OAXa,SAAPC,EAAQC,EAAcC,GAC1B,IAAMC,EAAOvB,EAASwB,IAAIH,GACtBE,EACFA,EAAKE,QAAQ,SAACC,GACZN,EAAMC,EAAgCK,GAAMJ,YAAWA,GAAMI,IAAO,CAACA,MAE9DJ,GACTH,EAAKQ,KAAKL,GAGdF,CAAKT,GACEQ,EAScS,CAAmBjB,EAAOX,KAE/C6B,EAAcd,GDiDZe,CAAsBnB,EAAOX,GAE/B,IAAM+B,EAAazB,EAAQ,sBAAUL,SAAW,IAChD,OAAO+B,EAAgBrB,EAAOX,EAAU+B"}